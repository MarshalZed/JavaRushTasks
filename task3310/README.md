Давай напишем укорачиватель Shortener.
Это будет некий аналог укорачивателя ссылок Google URL Shortener (https://goo.gl), но мы расширим его функциональность и сделаем консольным. Он будет сокращать не только ссылки, но и любые строки.
Наш Shortener - это класс, который может для любой строки вернуть некий уникальный идентификатор и наоборот, по ранее полученному идентификатору вернуть строку.

Два дополнительных требования к Shortener:
- для двух одинаковых строк должен возвращаться один и тот же идентификатор;
- он должен поддерживать столько строк, сколько значений может принимать long, именно этот тип будет использоваться для идентификатора.

Укорачиватель Shortener будет поддерживать разные стратегии хранения данных (строк и их идентификаторов). Все эти стратегии будут наследоваться от интерфейса StorageStrategy.
Наше хранилище будет оперировать двумя понятиями: ключ и значение. Ключом будет идентификатор строки, а значением сама строка.

Первое хранилище (стратегия хранилища) внутри будет содержать обычный HashMap. Все стратегии будем хранить в пакете strategy.

Вторая стратегия OurHashMapStorageStrategy. Она не будет использовать готовый HashMap из стандартной библиотеки, а будет сама являться коллекцией.

Еще одна стратегия, назовем ее FileStorageStrategy. Она будет очень похожа на стратегию OurHashMapStorageStrategy, но в качестве ведер (англ. buckets) будут файлы. 

Получение идентификатора для строки требует намного больше времени, чем получение строки по идентификатору. Это ожидаемо и следует из реализации HashMap. Напишем четвертую стратегию OurHashBiMapStorageStrategy, которая будет лишена этого недостатка.

Задача, когда требуется создать Map, работающий в две стороны (по ключу получать значение, а по значению ключ) не такая уж и редкая. Такие коллекции уже реализованы в различных сторонних библиотеках коллекций. Одна из таких Guava от Google.
Реализуем на ее основе стратегию HashBiMapStorageStrategy.

Еще одна реализация BiMap, на этот раз из Apache Commons Collections. Назовем эту стратегию DualHashBidiMapStorageStrategy.

Мы много раз тестировали наши стратегии с помощью метода testStrategy() класса Solution. Пришло время написать настоящие юнит тесты с использованием junit.

Еще добавим стратегию, основанную на работе с базой данных - JDBCStorageStrategy.

И сратегия OurMultiThreadHashMapStorageStrategy - вариант HashMap с использованием двух потоков, где один поток будет отвечать за работу с элементами, а второй следить за количеством элементов. Когда количество элементов превысит порог threshold, второй поток должен увеличить размер table в 2 раза. При этом, первый поток ничего не должен знать о пороге.